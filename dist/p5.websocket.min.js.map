{"mappings":"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","sources":["src/index.js","src/initialize.js","src/socket.js","src/utils.js"],"sourcesContent":["// keep this file as simple as possible since it is difficult to test\nimport { initialize } from \"./initialize\";\n\nwindow.WS_DEBUG = false;\n\nconst p5 = window.p5;\n\ninitialize(p5);\n","import { startWebsocket } from \"./socket\";\nimport { serialize } from \"./utils\";\n\nexport const initialize = (p5) => {\n  let socket = null;\n\n  const defaultOptions = {\n    echo: true,\n    receiver: true,\n    controller: true,\n  };\n\n  p5.prototype.connectWebsocket = function (url, options = {}) {\n    const config = Object.assign({}, defaultOptions, options);\n    const fullUrl = url + \"?\" + serialize(config);\n\n    socket = startWebsocket(fullUrl);\n\n    // this client's connection\n    socket.on(\"onopen\", (uid) => {\n      if (window.onConnection) {\n        onConnection(uid);\n      }\n    });\n\n    // this client's connection\n    socket.on(\"onclose\", () => {\n      if (window.onDisconnection) {\n        onDisconnection();\n      }\n    });\n\n    // other clients' connections\n    socket.on(\"connect\", (message) => {\n      if (window.connectReceived) {\n        connectReceived(message);\n      }\n    });\n\n    socket.on(\"disconnect\", (message) => {\n      if (window.disconnectReceived) {\n        disconnectReceived(message);\n      }\n    });\n\n    socket.on(\"data\", (message, uid) => {\n      if (window.messageReceived) {\n        messageReceived(message, uid);\n      }\n    });\n  };\n\n  p5.prototype.sendMessage = (message) => {\n    if (socket) {\n      if (window.WS_DEBUG) console.log(\"sendin\", message);\n      socket.emit(\"send\", message);\n    }\n  };\n};\n","//\n// The internal WebSocket wrapping interface. You should never need to access\n// this directly from p5.js sketches.\n//\nimport EventEmitter3 from \"eventemitter3\";\nimport Debug from \"debug\";\n\nconst debug = Debug('p5.websocket:socket');\n\nfunction tryParse(jsonString) {\n  debug('try parsing', jsonString);\n  try {\n    const data = JSON.parse(jsonString);\n    return data;\n  } catch (ex) {\n    // expect that messages may be plain strings\n    debug(\"failed to parse as JSON:\", jsonString);\n    return jsonString;\n  }\n}\n\nclass WebSocketClient {\n  constructor() {\n    this.reconnect_interval = 1500;\n  }\n\n  open(url) {\n    this.url = url;\n    this.instance = new WebSocket(this.url);\n\n    const self = this;\n\n    this.instance.onopen = function () {\n      debug(\"[WebSocketClient on open]\");\n      self.onopen();\n    };\n\n    this.instance.onclose = function (evt) {\n      debug(\"[WebSocketClient on close]\");\n      switch (evt.code) {\n        case 1000: // CLOSE_NORMAL\n          debug(\"WebSocketClient: closed\");\n          break;\n        default:\n          // Abnormal closure\n          self.reconnect(evt);\n          break;\n      }\n      if (self.onclose) self.onclose(evt);\n    };\n\n    this.instance.onerror = function (evt) {\n      debug(\"[WebSocketClient on error]\");\n      switch (evt.code) {\n        case \"ECONNREFUSED\":\n          self.reconnect(evt);\n          break;\n        default:\n          if (self.onerror) self.onerror(evt);\n          break;\n      }\n    };\n\n    this.instance.onmessage = function (evt) {\n      debug(\"[WebSocketClient on message]\");\n      self.onmessage(evt.data);\n    };\n\n    debug(\"[WebSocketClient open] completed\");\n  }\n\n  removeAllListeners() {\n    this.instance.onopen = null;\n    this.instance.onclose = null;\n    this.instance.onerror = null;\n    this.instance.onmessage = null;\n  }\n\n  reconnect(evt) {\n    debug(\n      \"WebSocketClient: retry in\",\n      this.reconnect_interval,\n      \"ms\",\n      evt\n    );\n    this.removeAllListeners();\n\n    const self = this;\n    setTimeout(function () {\n      debug(\"WebSocketClient: reconnecting...\");\n      self.open(self.url);\n    }, this.reconnect_interval);\n  }\n\n  send(message) {\n    if (typeof message === \"string\") {\n      this.instance.send(message);\n    } else {\n      this.instance.send(JSON.stringify(message));\n    }\n  }\n\n  // detach event listeners and close the socket\n  close() {\n    if (this.instance.readyState !== WebSocket.CLOSED) {\n      this.instance.close();\n    }\n  }\n}\n\nexport const startWebsocket = (url) => {\n  const socketEvents = new EventEmitter3();\n  const sock = new WebSocketClient(socketEvents);\n\n  sock.open(url);\n\n  function send(message) {\n    sock.send(message);\n  }\n\n  function close() {\n    try {\n      sock.close();\n    } catch (ex) {\n      console.error(\"close failed\", ex.message);\n    }\n  }\n\n  socketEvents.on(\"close\", close);\n\n  sock.onopen = function () {\n    debug(\"socket connected\");\n\n    // external client-to-library API \"methods\"\n    socketEvents.on(\"send\", send);\n  };\n\n  sock.onclose = function () {\n    debug(\"socket closed\");\n    socketEvents.removeListener(\"send\", send);\n    socketEvents.removeListener(\"close\", close);\n    socketEvents.emit(\"onclose\");\n  };\n  sock.onerror = sock.onclose;\n\n  function handleDataString(data) {\n    const message = JSON.parse(data);\n\n    if (message.type) {\n      switch (message.type) {\n        case \"onopen\":\n          socketEvents.emit(\"onopen\", message.id);\n          break;\n        case \"connect\":\n          socketEvents.emit(\"connect\", message.id);\n          break;\n        case \"disconnect\":\n          socketEvents.emit(\"disconnect\", message.id);\n          break;\n        case \"data\":\n          debug(\"receiving data\", message);\n          // try parsing data in case it's double-wrapped JSON\n          let data = tryParse(message.data);\n          socketEvents.emit(\"data\", data, message.id);\n          break;\n      }\n    } else {\n      socketEvents.emit(\"data\", message, message.id);\n    }\n  }\n\n  sock.onmessage = function (data) {\n    if (data instanceof Blob || data instanceof Buffer) {\n      debug('message data is Blob || Buffer');\n      const reader = new FileReader();\n      reader.onload = function () {\n        handleDataString(reader.result);\n      };\n      reader.readAsText(data);\n    } else if (typeof data == \"string\") {\n      debug('message data is string');\n      handleDataString(data);\n    }\n  };\n\n  return socketEvents;\n};\n","// naive query params serializer\nexport const serialize = (obj) => {\n  return Object.keys(obj)\n    .map((key) => encodeURIComponent(key) + \"=\" + encodeURIComponent(obj[key]))\n    .join(\"&\");\n};\n"],"names":[],"version":3,"file":"p5.websocket.min.js.map","sourceRoot":"../"}